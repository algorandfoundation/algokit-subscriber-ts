<!DOCTYPE html><html class="default" lang="en" data-base="../"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>subscriber | @algorandfoundation/algokit-subscriber</title><meta name="description" content="Documentation for @algorandfoundation/algokit-subscriber"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => window.app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><a href="../index.html" class="title">@algorandfoundation/algokit-subscriber</a><div id="tsd-toolbar-links"></div><button id="tsd-search-trigger" class="tsd-widget" aria-label="Search"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></button><dialog id="tsd-search" aria-label="Search"><input role="combobox" id="tsd-search-input" aria-controls="tsd-search-results" aria-autocomplete="list" aria-expanded="true" autocapitalize="off" autocomplete="off" placeholder="Search the docs" maxLength="100"/><ul role="listbox" id="tsd-search-results"></ul><div id="tsd-search-status" aria-live="polite" aria-atomic="true"><div>Preparing search index...</div></div></dialog><a href="#" class="tsd-widget menu" id="tsd-toolbar-menu-trigger" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb" aria-label="Breadcrumb"><li><a href="" aria-current="page">subscriber</a></li></ul></div><div class="tsd-panel tsd-typography"><h1 id="" class="tsd-anchor-link"><code>AlgorandSubscriber</code></h1><p><code>AlgorandSubscriber</code> is a class that allows you to easily subscribe to the Algorand Blockchain, define a series of events that you are interested in, and react to those events. It has a similar programming model to <a href="https://nodejs.org/docs/latest/api/events.html">EventEmitter</a>, but also supports async/await.</p>
<h2 id="creating-a-subscriber" class="tsd-anchor-link">Creating a subscriber<a href="#creating-a-subscriber" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>To create an <code>AlgorandSubscriber</code> you can use the constructor:</p>
<pre><code class="typescript"><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * Create a new `AlgorandSubscriber`.</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">config</span><span class="hl-3"> The subscriber configuration</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">algod</span><span class="hl-3"> An algod client</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">indexer</span><span class="hl-3"> An (optional) indexer client; only needed if `subscription.syncBehaviour` is `catchup-with-indexer`</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-6">constructor</span><span class="hl-1">(</span><span class="hl-0">config</span><span class="hl-1">: </span><span class="hl-0">AlgorandSubscriberConfig</span><span class="hl-1">, </span><span class="hl-0">algod</span><span class="hl-1">: </span><span class="hl-0">Algodv2</span><span class="hl-1">, </span><span class="hl-0">indexer</span><span class="hl-1">?: </span><span class="hl-0">Indexer</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>The key configuration is the <code>AlgorandSubscriberConfig</code> interface:</p>
<pre><code class="typescript"><span class="hl-3">/** Configuration for an `AlgorandSubscriber`. */</span><br/><span class="hl-11">export</span><span class="hl-1"> </span><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-12">AlgorandSubscriberConfig</span><span class="hl-1"> </span><span class="hl-4">extends</span><span class="hl-1"> </span><span class="hl-12">CoreTransactionSubscriptionParams</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-3">/** The set of filters to subscribe to / emit events for, along with optional data mappers. */</span><br/><span class="hl-1">  </span><span class="hl-0">filters</span><span class="hl-1">: </span><span class="hl-12">SubscriberConfigFilter</span><span class="hl-1">&lt;</span><span class="hl-12">unknown</span><span class="hl-1">&gt;[]</span><br/><span class="hl-1">  </span><span class="hl-3">/** The frequency to poll for new blocks in seconds; defaults to 1s */</span><br/><span class="hl-1">  </span><span class="hl-0">frequencyInSeconds</span><span class="hl-1">?: </span><span class="hl-12">number</span><br/><span class="hl-1">  </span><span class="hl-3">/** Whether to wait via algod `/status/wait-for-block-after` endpoint when at the tip of the chain; reduces latency of subscription */</span><br/><span class="hl-1">  </span><span class="hl-0">waitForBlockWhenAtTip</span><span class="hl-1">?: </span><span class="hl-12">boolean</span><br/><span class="hl-1">  </span><span class="hl-3">/** Methods to retrieve and persist the current watermark so syncing is resilient and maintains</span><br/><span class="hl-3">   * its position in the chain */</span><br/><span class="hl-1">  </span><span class="hl-0">watermarkPersistence</span><span class="hl-1">: {</span><br/><span class="hl-1">    </span><span class="hl-3">/** Returns the current watermark that syncing has previously been processed to */</span><br/><span class="hl-1">    </span><span class="hl-6">get</span><span class="hl-1">: () </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-12">bigint</span><span class="hl-1">&gt;</span><br/><span class="hl-1">    </span><span class="hl-3">/** Persist the new watermark that has been processed */</span><br/><span class="hl-1">    </span><span class="hl-6">set</span><span class="hl-1">: (</span><span class="hl-0">newWatermark</span><span class="hl-1">: </span><span class="hl-12">bigint</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-12">void</span><span class="hl-1">&gt;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-3">/** Common parameters to control a single subscription pull/poll for both `AlgorandSubscriber` and `getSubscribedTransactions`. */</span><br/><span class="hl-11">export</span><span class="hl-1"> </span><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-12">CoreTransactionSubscriptionParams</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-3">/** The filter(s) to apply to find transactions of interest.</span><br/><span class="hl-3">   * A list of filters with corresponding names.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   *  filter: [{</span><br/><span class="hl-3">   *   name: &#39;asset-transfers&#39;,</span><br/><span class="hl-3">   *   filter: {</span><br/><span class="hl-3">   *     type: TransactionType.axfer,</span><br/><span class="hl-3">   *     //...</span><br/><span class="hl-3">   *   }</span><br/><span class="hl-3">   *  }, {</span><br/><span class="hl-3">   *   name: &#39;payments&#39;,</span><br/><span class="hl-3">   *   filter: {</span><br/><span class="hl-3">   *     type: TransactionType.pay,</span><br/><span class="hl-3">   *     //...</span><br/><span class="hl-3">   *   }</span><br/><span class="hl-3">   *  }]</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-0">filters</span><span class="hl-1">: </span><span class="hl-12">NamedTransactionFilter</span><span class="hl-1">[]</span><br/><span class="hl-1">  </span><span class="hl-3">/** Any ARC-28 event definitions to process from app call logs */</span><br/><span class="hl-1">  </span><span class="hl-0">arc28Events</span><span class="hl-1">?: </span><span class="hl-12">Arc28EventGroup</span><span class="hl-1">[]</span><br/><span class="hl-1">  </span><span class="hl-3">/** The maximum number of rounds to sync from algod for each subscription pull/poll.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * Defaults to 500.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * This gives you control over how many rounds you wait for at a time,</span><br/><span class="hl-3">   * your staleness tolerance when using `skip-sync-newest` or `fail`, and</span><br/><span class="hl-3">   * your catchup speed when using `sync-oldest`.</span><br/><span class="hl-3">   **/</span><br/><span class="hl-1">  </span><span class="hl-0">maxRoundsToSync</span><span class="hl-1">?: </span><span class="hl-12">number</span><br/><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * The maximum number of rounds to sync from indexer when using `syncBehaviour: &#39;catchup-with-indexer&#39;.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * By default there is no limit and it will paginate through all of the rounds.</span><br/><span class="hl-3">   * Sometimes this can result in an incredibly long catchup time that may break the service</span><br/><span class="hl-3">   * due to execution and memory constraints, particularly for filters that result in a large number of transactions.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * Instead, this allows indexer catchup to be split into multiple polls, each with a transactionally consistent</span><br/><span class="hl-3">   * boundary based on the number of rounds specified here.</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-0">maxIndexerRoundsToSync</span><span class="hl-1">?: </span><span class="hl-12">number</span><br/><span class="hl-1">  </span><span class="hl-3">/** If the current tip of the configured Algorand blockchain is more than `maxRoundsToSync`</span><br/><span class="hl-3">   * past `watermark` then how should that be handled:</span><br/><span class="hl-3">   *  * `skip-sync-newest`: Discard old blocks/transactions and sync the newest; useful</span><br/><span class="hl-3">   *    for real-time notification scenarios where you don&#39;t care about history and</span><br/><span class="hl-3">   *    are happy to lose old transactions.</span><br/><span class="hl-3">   *  * `sync-oldest`: Sync from the oldest rounds forward `maxRoundsToSync` rounds</span><br/><span class="hl-3">   *    using algod; note: this will be slow if you are starting from 0 and requires</span><br/><span class="hl-3">   *    an archival node.</span><br/><span class="hl-3">   *  * `sync-oldest-start-now`: Same as `sync-oldest`, but if the `watermark` is `0`</span><br/><span class="hl-3">   *    then start at the current round i.e. don&#39;t sync historical records, but once</span><br/><span class="hl-3">   *    subscribing starts sync everything; note: if it falls behind it requires an</span><br/><span class="hl-3">   *    archival node.</span><br/><span class="hl-3">   *  * `catchup-with-indexer`: Sync to round `currentRound - maxRoundsToSync + 1`</span><br/><span class="hl-3">   *    using indexer (much faster than using algod for long time periods) and then</span><br/><span class="hl-3">   *    use algod from there.</span><br/><span class="hl-3">   *  * `fail`: Throw an error.</span><br/><span class="hl-3">   **/</span><br/><span class="hl-1">  </span><span class="hl-0">syncBehaviour</span><span class="hl-1">: </span><span class="hl-7">&#39;skip-sync-newest&#39;</span><span class="hl-1"> | </span><span class="hl-7">&#39;sync-oldest&#39;</span><span class="hl-1"> | </span><span class="hl-7">&#39;sync-oldest-start-now&#39;</span><span class="hl-1"> | </span><span class="hl-7">&#39;catchup-with-indexer&#39;</span><span class="hl-1"> | </span><span class="hl-7">&#39;fail&#39;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p><code>watermarkPersistence</code> allows you to ensure reliability against your code having outages since you can persist the last block your code processed up to and then provide it again the next time your code runs.</p>
<p><code>maxRoundsToSync</code> and <code>syncBehaviour</code> allow you to control the subscription semantics as your code falls behind the tip of the chain (either on first run or after an outage).</p>
<p><code>frequencyInSeconds</code> allows you to control the polling frequency and by association your latency tolerance for new events once you've caught up to the tip of the chain. Alternatively, you can set <code>waitForBlockWhenAtTip</code> to get the subscriber to ask algod to tell it when there is a new block ready to reduce latency when it's caught up to the tip of the chain.</p>
<p><code>arc28Events</code> are any <a href="subscriptions.html#arc28eventgroup">ARC-28 event definitions</a>.</p>
<p>Filters defines the different subscription(s) you want to make, and is defined by the following interface:</p>
<pre><code class="typescript"><span class="hl-3">/** A single event to subscribe to / emit. */</span><br/><span class="hl-11">export</span><span class="hl-1"> </span><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-12">SubscriberConfigFilter</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1">&gt; </span><span class="hl-4">extends</span><span class="hl-1"> </span><span class="hl-12">NamedTransactionFilter</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-3">/** An optional data mapper if you want the event data to take a certain shape when subscribing to events with this filter name.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * If not specified, then the event will simply receive a `SubscribedTransaction`.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * Note: if you provide multiple filters with the same name then only the mapper of the first matching filter will be used</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-6">mapper</span><span class="hl-1">?: (</span><span class="hl-0">transaction</span><span class="hl-1">: </span><span class="hl-12">SubscribedTransaction</span><span class="hl-1">[]) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1">[]&gt;</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-3">/** Specify a named filter to apply to find transactions of interest. */</span><br/><span class="hl-11">export</span><span class="hl-1"> </span><span class="hl-4">interface</span><span class="hl-1"> </span><span class="hl-12">NamedTransactionFilter</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-3">/** The name to give the filter. */</span><br/><span class="hl-1">  </span><span class="hl-0">name</span><span class="hl-1">: </span><span class="hl-12">string</span><br/><span class="hl-1">  </span><span class="hl-3">/** The filter itself. */</span><br/><span class="hl-1">  </span><span class="hl-0">filter</span><span class="hl-1">: </span><span class="hl-12">TransactionFilter</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>The event name is a unique name that describes the event you are subscribing to. The <a href="subscriptions.html#transactionfilter">filter</a> defines how to interpret transactions on the chain as being &quot;collected&quot; by that event and the mapper is an optional ability to map from the raw transaction to a more targeted type for your event subscribers to consume.</p>
<h2 id="subscribing-to-events" class="tsd-anchor-link">Subscribing to events<a href="#subscribing-to-events" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Once you have created the <code>AlgorandSubscriber</code>, you can register handlers/listeners for the filters you have defined, or each poll as a whole batch.</p>
<p>You can do this via the <code>on</code>, <code>onBatch</code> and <code>onPoll</code> methods:</p>
<pre><code class="typescript"><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * Register an event handler to run on every subscribed transaction matching the given filter name.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * The listener can be async and it will be awaited if so.</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><span class="hl-3"> **Non-mapped**</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * subscriber.on(&#39;my-filter&#39;, async (transaction) =&gt; { console.log(transaction.id) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><span class="hl-3"> **Mapped**</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * new AlgorandSubscriber({filters: [{name: &#39;my-filter&#39;, filter: {...}, mapper: (t) =&gt; t.id}], ...}, algod)</span><br/><span class="hl-3">   *  .on&lt;string&gt;(&#39;my-filter&#39;, async (transactionId) =&gt; { console.log(transactionId) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">filterName</span><span class="hl-3"> The name of the filter to subscribe to</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">listener</span><span class="hl-3"> The listener function to invoke with the subscribed event</span><br/><span class="hl-3">   * </span><span class="hl-4">@returns</span><span class="hl-3"> The subscriber so `on*` calls can be chained</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-0">on</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1"> = </span><span class="hl-12">SubscribedTransaction</span><span class="hl-1">&gt;(</span><span class="hl-0">filterName</span><span class="hl-1">: </span><span class="hl-12">string</span><span class="hl-1">, </span><span class="hl-0">listener</span><span class="hl-1">: </span><span class="hl-12">TypedAsyncEventListener</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1">&gt;) {}</span><br/><br/><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * Register an event handler to run on all subscribed transactions matching the given filter name</span><br/><span class="hl-3">   * for each subscription poll.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * This is useful when you want to efficiently process / persist events</span><br/><span class="hl-3">   * in bulk rather than one-by-one.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * The listener can be async and it will be awaited if so.</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><span class="hl-3"> **Non-mapped**</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * subscriber.onBatch(&#39;my-filter&#39;, async (transactions) =&gt; { console.log(transactions.length) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><span class="hl-3"> **Mapped**</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * new AlgorandSubscriber({filters: [{name: &#39;my-filter&#39;, filter: {...}, mapper: (t) =&gt; t.id}], ...}, algod)</span><br/><span class="hl-3">   *  .onBatch&lt;string&gt;(&#39;my-filter&#39;, async (transactionIds) =&gt; { console.log(transactionIds) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">filterName</span><span class="hl-3"> The name of the filter to subscribe to</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">listener</span><span class="hl-3"> The listener function to invoke with the subscribed events</span><br/><span class="hl-3">   * </span><span class="hl-4">@returns</span><span class="hl-3"> The subscriber so `on*` calls can be chained</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-0">onBatch</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1"> = </span><span class="hl-12">SubscribedTransaction</span><span class="hl-1">&gt;(</span><span class="hl-0">filterName</span><span class="hl-1">: </span><span class="hl-12">string</span><span class="hl-1">, </span><span class="hl-0">listener</span><span class="hl-1">: </span><span class="hl-12">TypedAsyncEventListener</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1">[]&gt;) {}</span><br/><br/><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * Register an event handler to run before every subscription poll.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * This is useful when you want to do pre-poll logging or start a transaction etc.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * The listener can be async and it will be awaited if so.</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * subscriber.onBeforePoll(async (metadata) =&gt; { console.log(metadata.watermark) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">listener</span><span class="hl-3"> The listener function to invoke with the pre-poll metadata</span><br/><span class="hl-3">   * </span><span class="hl-4">@returns</span><span class="hl-3"> The subscriber so `on*` calls can be chained</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-6">onBeforePoll</span><span class="hl-1">(</span><span class="hl-0">listener</span><span class="hl-1">: </span><span class="hl-0">TypedAsyncEventListener</span><span class="hl-1">&lt;</span><span class="hl-0">TransactionSubscriptionResult</span><span class="hl-1">&gt;) {}</span><br/><br/><span class="hl-1">  </span><span class="hl-3">/**</span><br/><span class="hl-3">   * Register an event handler to run after every subscription poll.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * This is useful when you want to process all subscribed transactions</span><br/><span class="hl-3">   * in a transactionally consistent manner rather than piecemeal for each</span><br/><span class="hl-3">   * filter, or to have a hook that occurs at the end of each poll to commit</span><br/><span class="hl-3">   * transactions etc.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * The listener can be async and it will be awaited if so.</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * subscriber.onPoll(async (pollResult) =&gt; { console.log(pollResult.subscribedTransactions.length, pollResult.syncedRoundRange) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">listener</span><span class="hl-3"> The listener function to invoke with the poll result</span><br/><span class="hl-3">   * </span><span class="hl-4">@returns</span><span class="hl-3"> The subscriber so `on*` calls can be chained</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-6">onPoll</span><span class="hl-1">(</span><span class="hl-0">listener</span><span class="hl-1">: </span><span class="hl-0">TypedAsyncEventListener</span><span class="hl-1">&lt;</span><span class="hl-0">TransactionSubscriptionResult</span><span class="hl-1">&gt;) {}</span>
</code><button type="button">Copy</button></pre>

<p>The <code>TypedAsyncEventListener</code> type is defined as:</p>
<pre><code class="typescript"><span class="hl-4">type</span><span class="hl-1"> </span><span class="hl-12">TypedAsyncEventListener</span><span class="hl-1">&lt;</span><span class="hl-12">T</span><span class="hl-1">&gt; = (</span><span class="hl-0">event</span><span class="hl-1">: </span><span class="hl-12">T</span><span class="hl-1">, </span><span class="hl-0">eventName</span><span class="hl-1">: </span><span class="hl-12">string</span><span class="hl-1"> | </span><span class="hl-12">symbol</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-12">void</span><span class="hl-1">&gt; | </span><span class="hl-12">void</span>
</code><button type="button">Copy</button></pre>

<p>This allows you to use async or sync event listeners.</p>
<p>When you define an event listener it will be called, one-by-one (and awaited) in the order the registrations occur.</p>
<p>If you call <code>onBatch</code> it will be called first, with the full set of transactions that were found in the current poll (0 or more). Following that, each transaction in turn will then be passed to the listener(s) that subscribed with <code>on</code> for that event.</p>
<p>The default type that will be received is a <code>SubscribedTransaction</code>, which can be imported like so:</p>
<pre><code class="typescript"><span class="hl-11">import</span><span class="hl-1"> </span><span class="hl-11">type</span><span class="hl-1"> { </span><span class="hl-0">SubscribedTransaction</span><span class="hl-1"> } </span><span class="hl-11">from</span><span class="hl-1"> </span><span class="hl-7">&#39;@algorandfoundation/algokit-subscriber/types&#39;</span>
</code><button type="button">Copy</button></pre>

<p>See the <a href="subscriptions.html#subscribedtransaction">detail about this type</a>.</p>
<p>Alternatively, if you defined a mapper against the filter then it will be applied before passing the objects through.</p>
<p>If you call <code>onPoll</code> it will be called last (after all <code>on</code> and <code>onBatch</code> listeners) for each poll, with the full set of transactions for that poll and <a href="subscriptions.html#transactionsubscriptionresult">metadata about the poll result</a>. This allows you to process the entire poll batch in one transaction or have a hook to call after processing individual listeners (e.g. to commit a transaction).</p>
<p>If you want to run code before a poll starts (e.g. to log or start a transaction) you can do so with <code>onBeforePoll</code>.</p>
<h2 id="poll-the-chain" class="tsd-anchor-link">Poll the chain<a href="#poll-the-chain" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>There are two methods to poll the chain for events: <code>pollOnce</code> and <code>start</code>:</p>
<pre><code class="typescript"><span class="hl-3">/**</span><br/><span class="hl-3"> * Execute a single subscription poll.</span><br/><span class="hl-3"> *</span><br/><span class="hl-3"> * This is useful when executing in the context of a process</span><br/><span class="hl-3"> * triggered by a recurring schedule / cron.</span><br/><span class="hl-3"> * </span><span class="hl-4">@returns</span><span class="hl-3"> The poll result</span><br/><span class="hl-3"> */</span><br/><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-6">pollOnce</span><span class="hl-1">(): </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-0">TransactionSubscriptionResult</span><span class="hl-1">&gt; {}</span><br/><br/><span class="hl-3">/**</span><br/><span class="hl-3"> * Start the subscriber in a loop until `stop` is called.</span><br/><span class="hl-3"> *</span><br/><span class="hl-3"> * This is useful when running in the context of a long-running process / container.</span><br/><span class="hl-3"> * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">inspect</span><span class="hl-3"> A function that is called for each poll so the inner workings can be inspected / logged / etc.</span><br/><span class="hl-3"> * </span><span class="hl-4">@returns</span><span class="hl-3"> An object that contains a promise you can wait for after calling stop</span><br/><span class="hl-3"> */</span><br/><span class="hl-6">start</span><span class="hl-1">(</span><span class="hl-0">inspect</span><span class="hl-1">?: (</span><span class="hl-0">pollResult</span><span class="hl-1">: </span><span class="hl-12">TransactionSubscriptionResult</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-4">void</span><span class="hl-1">, </span><span class="hl-0">suppressLog</span><span class="hl-1">?: </span><span class="hl-0">boolean</span><span class="hl-1">): </span><span class="hl-4">void</span><span class="hl-1"> {}</span>
</code><button type="button">Copy</button></pre>

<p><code>pollOnce</code> is useful when you want to take control of scheduling the different polls, such as when running a Lambda on a schedule or a process via cron, etc. - it will do a single poll of the chain and return the result of that poll.</p>
<p><code>start</code> is useful when you have a long-running process or container and you want it to loop infinitely at the specified polling frequency from the constructor config. If you want to inspect or log what happens under the covers you can pass in an <code>inspect</code> lambda that will be called for each poll.</p>
<p>If you use <code>start</code> then you can stop the polling by calling <code>stop</code>, which can be awaited to wait until everything is cleaned up. You may want to subscribe to Node.JS kill signals to exit cleanly:</p>
<pre><code class="typescript"><span class="hl-1">;[</span><span class="hl-7">&#39;SIGINT&#39;</span><span class="hl-1">, </span><span class="hl-7">&#39;SIGTERM&#39;</span><span class="hl-1">, </span><span class="hl-7">&#39;SIGQUIT&#39;</span><span class="hl-1">].</span><span class="hl-6">forEach</span><span class="hl-1">((</span><span class="hl-0">signal</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><br/><span class="hl-1">  </span><span class="hl-0">process</span><span class="hl-1">.</span><span class="hl-6">on</span><span class="hl-1">(</span><span class="hl-0">signal</span><span class="hl-1">, () </span><span class="hl-4">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-3">// eslint-disable-next-line no-console</span><br/><span class="hl-1">    </span><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-7">`Received </span><span class="hl-4">${</span><span class="hl-0">signal</span><span class="hl-4">}</span><span class="hl-7">; stopping subscriber...`</span><span class="hl-1">)</span><br/><span class="hl-1">    </span><span class="hl-0">subscriber</span><span class="hl-1">.</span><span class="hl-6">stop</span><span class="hl-1">(</span><span class="hl-0">signal</span><span class="hl-1">).</span><span class="hl-6">then</span><span class="hl-1">(() </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-6">log</span><span class="hl-1">(</span><span class="hl-7">&#39;Subscriber stopped&#39;</span><span class="hl-1">))</span><br/><span class="hl-1">  }),</span><br/><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<h2 id="handling-errors" class="tsd-anchor-link">Handling errors<a href="#handling-errors" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Because <code>start</code> isn't a blocking method, you can't simply wrap it in a try/catch.
To handle errors, you can register error handlers/listeners using the <code>onError</code> method. This works in a similar way to the other <code>on*</code> methods.</p>
<pre><code class="typescript"><span class="hl-3">/**</span><br/><span class="hl-3">   * Register an error handler to run if an error is thrown during processing or event handling.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * This is useful to handle any errors that occur and can be used to perform retries, logging or cleanup activities.</span><br/><span class="hl-3">   *</span><br/><span class="hl-3">   * The listener can be async and it will be awaited if so.</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * subscriber.onError((error) =&gt; { console.error(error) })</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@example</span><br/><span class="hl-3">   * ```typescript</span><br/><span class="hl-3">   * const maxRetries = 3</span><br/><span class="hl-3">   * let retryCount = 0</span><br/><span class="hl-3">   * subscriber.onError(async (error) =&gt; {</span><br/><span class="hl-3">   *   retryCount++</span><br/><span class="hl-3">   *   if (retryCount &gt; maxRetries) {</span><br/><span class="hl-3">   *     console.error(error)</span><br/><span class="hl-3">   *     return</span><br/><span class="hl-3">   *   }</span><br/><span class="hl-3">   *   console.log(`Error occurred, retrying in 2 seconds (${retryCount}/${maxRetries})`)</span><br/><span class="hl-3">   *   await new Promise((r) =&gt; setTimeout(r, 2_000))</span><br/><span class="hl-3">   *   subscriber.start()</span><br/><span class="hl-3">   *})</span><br/><span class="hl-3">   * ```</span><br/><span class="hl-3">   * </span><span class="hl-4">@param</span><span class="hl-3"> </span><span class="hl-0">listener</span><span class="hl-3"> The listener function to invoke with the error that was thrown</span><br/><span class="hl-3">   * </span><span class="hl-4">@returns</span><span class="hl-3"> The subscriber so `on*` calls can be chained</span><br/><span class="hl-3">   */</span><br/><span class="hl-1">  </span><span class="hl-6">onError</span><span class="hl-1">(</span><span class="hl-0">listener</span><span class="hl-1">: </span><span class="hl-0">ErrorListener</span><span class="hl-1">) {}</span>
</code><button type="button">Copy</button></pre>

<p>The <code>ErrorListener</code> type is defined as:</p>
<pre><code class="typescript"><span class="hl-4">type</span><span class="hl-1"> </span><span class="hl-12">ErrorListener</span><span class="hl-1"> = (</span><span class="hl-0">error</span><span class="hl-1">: </span><span class="hl-12">unknown</span><span class="hl-1">) </span><span class="hl-4">=&gt;</span><span class="hl-1"> </span><span class="hl-12">Promise</span><span class="hl-1">&lt;</span><span class="hl-12">void</span><span class="hl-1">&gt; | </span><span class="hl-12">void</span>
</code><button type="button">Copy</button></pre>

<p>This allows you to use async or sync error listeners.</p>
<p>Multiple error listeners can be added, and each will be called one-by-one (and awaited) in the order the registrations occur.</p>
<p>When no error listeners have been registered, a default listener is used to re-throw any exception, so they can be caught by global uncaught exception handlers.
Once an error listener has been registered, the default listener is removed and it's the responsibility of the registered error listener to perform any error handling.</p>
<h2 id="examples" class="tsd-anchor-link">Examples<a href="#examples" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>See the <a href="../media/README.md#examples">main README</a>.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#"><span></span></a><ul><li><a href="#creating-a-subscriber"><span>Creating a subscriber</span></a></li><li><a href="#subscribing-to-events"><span>Subscribing to events</span></a></li><li><a href="#poll-the-chain"><span>Poll the chain</span></a></li><li><a href="#handling-errors"><span>Handling errors</span></a></li><li><a href="#examples"><span>Examples</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">@algorandfoundation/algokit-subscriber</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
